"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-src_app_services_user-info_service_ts-node_modules_ng-in-viewport_fesm2020_ng-in-view-91fa76"],{

/***/ 5360:
/*!***********************************************!*\
  !*** ./src/app/services/user-info.service.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserInfoService": () => (/* binding */ UserInfoService)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ 4929);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 2560);


let UserInfoService = class UserInfoService {
    constructor() {
        this.userAvatar = 0;
        this.userName = "master";
    }
    getUserAvatar() {
        return this.userAvatar;
    }
    setUserAvatar(index) {
        this.userAvatar = index;
    }
    setUserName(name) {
        this.userName = name;
    }
    getUserName() {
        return this.userName;
    }
};
UserInfoService.ctorParameters = () => [];
UserInfoService = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable)({
        providedIn: 'root'
    })
], UserInfoService);



/***/ }),

/***/ 108:
/*!*****************************************************************!*\
  !*** ./node_modules/ng-in-viewport/fesm2020/ng-in-viewport.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InViewportConfig": () => (/* binding */ InViewportConfig),
/* harmony export */   "InViewportConfigDirection": () => (/* binding */ InViewportConfigDirection),
/* harmony export */   "InViewportDirective": () => (/* binding */ InViewportDirective),
/* harmony export */   "InViewportMetadata": () => (/* binding */ InViewportMetadata),
/* harmony export */   "InViewportModule": () => (/* binding */ InViewportModule),
/* harmony export */   "InViewportService": () => (/* binding */ InViewportService)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ 4666);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 2560);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 2218);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 9151);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 5921);





/**
 * @license
 * Copyright Piotr Stępniewski <k3nsei.pl@gmail.com> All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/k3nsei/ng-in-viewport/stable/LICENSE
 */

var InViewportConfigDirection;

(function (InViewportConfigDirection) {
  InViewportConfigDirection["BOTH"] = "both";
  InViewportConfigDirection["VERTICAL"] = "vertical";
  InViewportConfigDirection["HORIZONTAL"] = "horizontal";
})(InViewportConfigDirection || (InViewportConfigDirection = {}));

const isPlatformBrowser = new Function(`
  try {
    return typeof window !== 'undefined' && this === window;
  } catch(e) {
    return false;
  }
`);
const toBase64 = !isPlatformBrowser() ? new Function('input', `return Buffer.from(input).toString('base64')`) : new Function('input', 'return btoa(input)');

class InViewportConfig {
  constructor(options) {
    this._rootMargin = '0px 0px 0px 0px';
    this._threshold = [...InViewportConfig.DEFAULT_THRESHOLD];
    this._partial = true;
    this._direction = InViewportConfigDirection.BOTH;

    if (Object.prototype.toString.call(options) === '[object Object]') {
      ['root', 'rootMargin', 'threshold', 'partial', 'direction', 'checkFn'].forEach(prop => {
        if (options?.hasOwnProperty(prop)) {
          // @ts-ignore setters do value validation
          this[prop] = options[prop];
        }
      });
    }

    this._hash = InViewportConfig.hash({
      rootMargin: this.rootMargin,
      threshold: this.threshold,
      partial: this.partial,
      direction: this.direction,
      checkFn: String(this.checkFn)
    });
  }

  static get DEFAULT_THRESHOLD() {
    return [0, 1];
  }

  static get STRINGIFY_DELIMITER() {
    return '|';
  }

  static stringify(input) {
    if (Array.isArray(input)) {
      const stringifiedArr = [];

      for (let i = 0; i < input.length; i++) {
        stringifiedArr.push(InViewportConfig.stringify(input[i]));
      }

      return `[${stringifiedArr.join(',')}]`;
    } else if (typeof input === 'object' && input !== null) {
      const acc = [];
      const sortedKeys = Object.keys(input).sort();

      for (const k of sortedKeys) {
        const v = InViewportConfig.stringify(input[k]);
        acc.push(`${k}:${v}`);
      }

      return acc.join(InViewportConfig.STRINGIFY_DELIMITER);
    }

    return String(input);
  }

  static hash(input) {
    return toBase64(InViewportConfig.stringify(input));
  }

  get root() {
    return this._root;
  }

  set root(value) {
    this._root = value && value.nodeType === 1 ? value : undefined;
  }

  get rootMargin() {
    return this._rootMargin;
  }

  set rootMargin(value) {
    if (!value || typeof value !== 'string') {
      this._rootMargin = '0px 0px 0px 0px';
    } else {
      const marginString = value || '0px';
      const margins = marginString.split(new RegExp('\\s+')).map(margin => {
        const parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);

        if (!parts) {
          throw new TypeError('rootMargin must be specified in pixels or percent');
        }

        return `${parts[1]}${parts[2]}`;
      });
      margins[1] = margins[1] || margins[0];
      margins[2] = margins[2] || margins[0];
      margins[3] = margins[3] || margins[1];
      this._rootMargin = margins.join(' ');
    }
  }

  get threshold() {
    return this._threshold;
  }

  set threshold(value) {
    let threshold = [];

    const isValidThreshold = val => typeof val === 'number' && val >= 0 && val <= 1;

    if (isValidThreshold(value)) {
      threshold = [value];
    } else if (Array.isArray(value) && value.length) {
      threshold = value.filter(val => isValidThreshold(val));
    }

    if (threshold.length === 0) {
      threshold = [...InViewportConfig.DEFAULT_THRESHOLD];
    }

    this._threshold = threshold;
  }

  get partial() {
    return this._partial;
  }

  set partial(value) {
    this._partial = !!value;
  }

  get direction() {
    return this._direction;
  }

  set direction(value) {
    const isValidValue = val => {
      return [InViewportConfigDirection.BOTH, InViewportConfigDirection.HORIZONTAL, InViewportConfigDirection.VERTICAL].indexOf(val) >= 0;
    };

    this._direction = isValidValue(value) ? value : InViewportConfigDirection.BOTH;
  }

  get hash() {
    return this._hash;
  }

  get checkFn() {
    return this._checkFn;
  }

  set checkFn(value) {
    this._checkFn = value;
  }

}
/**
 * @license
 * Copyright Piotr Stępniewski <k3nsei.pl@gmail.com> All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/k3nsei/ng-in-viewport/stable/LICENSE
 */


class InViewportService {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.trigger$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
    this.registry = [];
  }

  emitTrigger(entries) {
    if (Array.isArray(entries) && entries.length) {
      entries.forEach(entry => this.trigger$.next(entry));
    }
  }

  getRootElement(element) {
    return element && element.nodeType === Node.ELEMENT_NODE ? element : undefined;
  }

  findEntry(root, configHash) {
    return this.registry.find(entry => entry.root === this.getRootElement(root) && entry.configHash === configHash);
  }

  register(target, config) {
    this.ngZone.runOutsideAngular(() => {
      const foundedEntry = this.findEntry(config.root, config.hash);

      if (foundedEntry && !foundedEntry.targets.has(target)) {
        foundedEntry.targets.add(target);
        foundedEntry.observer.observe(target);
      } else {
        const root = this.getRootElement(config.root);
        const options = {
          root: root,
          rootMargin: config.rootMargin,
          threshold: config.threshold
        };
        const entry = {
          root: root,
          configHash: config.hash,
          targets: new Set([target]),
          observer: new IntersectionObserver(entries => this.ngZone.run(() => this.emitTrigger(entries)), options)
        };
        entry.observer.observe(target);
        this.registry = [...this.registry, entry];
      }
    });
  }

  unregister(target, config) {
    this.ngZone.runOutsideAngular(() => {
      const foundedEntry = this.findEntry(config.root, config.hash);

      if (foundedEntry) {
        const {
          observer,
          targets
        } = foundedEntry;

        if (targets.has(target)) {
          observer.unobserve(target);
          targets.delete(target);
        }

        if (targets.size === 0) {
          observer.disconnect();
          this.registry = this.registry.filter(entry => entry !== foundedEntry);
        }
      }
    });
  }

}

InViewportService.ɵfac = function InViewportService_Factory(t) {
  return new (t || InViewportService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone));
};

InViewportService.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: InViewportService,
  factory: InViewportService.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](InViewportService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone
    }];
  }, null);
})();
/**
 * @license
 * Copyright Piotr Stępniewski <k3nsei.pl@gmail.com> All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/k3nsei/ng-in-viewport/stable/LICENSE
 */


const InViewportMetadata = Symbol('InViewportMetadata');

class InViewportDirective {
  constructor(platformId, elementRef, inViewport) {
    this.platformId = platformId;
    this.elementRef = elementRef;
    this.inViewport = inViewport;
    this.inViewportAction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
    this.config = new InViewportConfig();
    this.destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
  }

  set options(value) {
    this.config = new InViewportConfig(value);
  }

  ngAfterViewInit() {
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.isPlatformBrowser)(this.platformId)) {
      this.inViewport.register(this.elementRef.nativeElement, this.config);
      this.inViewport.trigger$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(entry => entry && entry.target === this.elementRef.nativeElement), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this.destroyed$)).subscribe(entry => this.emitAction(entry, false));
    } else {
      this.emitAction(undefined, true);
    }
  }

  ngOnDestroy() {
    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.isPlatformBrowser)(this.platformId)) {
      this.inViewport.unregister(this.elementRef.nativeElement, this.config);
    }

    if (this.destroyed$ && !this.destroyed$.closed) {
      this.destroyed$.next();
      this.destroyed$.complete();
    }
  }

  check(entry, force) {
    const isVisible = () => {
      const {
        isIntersecting = true,
        intersectionRatio = 1
      } = entry ?? {};
      const partiallyVisible = isIntersecting || intersectionRatio > 0;
      const completelyVisible = intersectionRatio >= 1;
      return this.config.partial ? partiallyVisible : completelyVisible;
    };

    const visible = force || !entry || isVisible();
    return {
      [InViewportMetadata]: {
        entry
      },
      target: this.elementRef.nativeElement,
      visible
    };
  }

  emitAction(entry, force) {
    const event = this.config.checkFn ? this.config.checkFn(entry, {
      force,
      config: this.config
    }) : this.check(entry, force);
    this.inViewportAction.emit(event);
  }

}

InViewportDirective.ɵfac = function InViewportDirective_Factory(t) {
  return new (t || InViewportDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](InViewportService));
};

InViewportDirective.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
  type: InViewportDirective,
  selectors: [["", "inViewport", ""]],
  inputs: {
    options: ["inViewportOptions", "options"]
  },
  outputs: {
    inViewportAction: "inViewportAction"
  }
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](InViewportDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,
    args: [{
      selector: '[inViewport]'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef
    }, {
      type: InViewportService
    }];
  }, {
    options: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,
      args: ['inViewportOptions']
    }],
    inViewportAction: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output
    }]
  });
})();
/**
 * @license
 * Copyright Piotr Stępniewski <k3nsei.pl@gmail.com> All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/k3nsei/ng-in-viewport/stable/LICENSE
 */


class InViewportModule {}

InViewportModule.ɵfac = function InViewportModule_Factory(t) {
  return new (t || InViewportModule)();
};

InViewportModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
  type: InViewportModule,
  declarations: [InViewportDirective],
  imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule],
  exports: [InViewportDirective]
});
InViewportModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
  imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](InViewportModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule],
      declarations: [InViewportDirective],
      exports: [InViewportDirective]
    }]
  }], null, null);
})();
/**
 * @license
 * Copyright Piotr Stępniewski <k3nsei.pl@gmail.com> All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/k3nsei/ng-in-viewport/stable/LICENSE
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-src_app_services_user-info_service_ts-node_modules_ng-in-viewport_fesm2020_ng-in-view-91fa76.js.map